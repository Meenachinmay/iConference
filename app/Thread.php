<?php

namespace App;

use App\Notifications\ThreadGotReply;
use Illuminate\Database\Eloquent\Model;
use App\ThreadSubscription;

/**
 * @property mixed subscriptions
 */
class Thread extends Model
{
    use RecordsActivity;

    protected $fillable = ['user_id', 'channel_id', 'title', 'body'];

    protected $with = ['creater', 'channel'];

    protected $appends = ['isSubscribedTo'];


    protected static function boot()
    {
        parent::boot(); // TODO: Change the autogenerated stub

        // deleting all the associated replies with a thread when deleting the thread
        static::deleting(function ($thread){

           $thread->replies->each(function ($reply) {

               $reply->delete();

           });

        });

    }

    // path for a single thread view
    public function path()
    {
        return "/threads/{$this->channel->slug}/{$this->id}";
    }


    // A thread can have many replies
    public function replies()
    {
        // fetching the replies for every thread but also along with that fetching the favorite count too for every reply
        // this will decrease the number of queries per request and make process even more faster
        return $this->hasMany('App\Reply');
    }


    // A thread can have a user
    public function creater(){
        return $this->belongsTo(User::class, 'user_id');
    }


    // a thread can have an channel
    public function channel() {
        return $this->belongsTo(Channel::class);
    }


    // a thread can have an channel
    public function scopeFilter($query, $filters)
    {
        // applying the query through filters in short applying filters on query
        return $filters->apply($query);
    }

    // add a new reply by this method in RepliesController
    public function addReply($reply)
    {
        // this will take thread id automatically because Thread has a one to many relationship with Reply
        // create a reply
        $reply =  $this->replies()->create($reply);

        $this->notifySubscribers($reply);

        return $reply;
    }

    // method to notify to all subscribers
    public function notifySubscribers($reply)
    {
        // get all the subscribers and send them notifications
        $this->subscriptions
            ->where('user_id', '!=', $reply->user_id)
            ->each
            ->notify($reply);

    }

    public function getIsSubscribedToAttribute()
    {
        return $this->subscriptions()
            ->where('user_id', auth()->id())
            ->exists();
    }


    public function subscribe($userId = null)
    {
        $this->subscriptions()->create([
            'user_id' => $userId ?: auth()->id(),
        ]);
    }


    public function unsubscribe($userId = null)
    {
        $this->subscriptions()->where([
            'user_id' => $userId ?: auth()->id(),
        ])->delete();
    }


    // a thread can have subscriptions
    public function subscriptions()
    {
        return $this->hasMany(ThreadSubscription::class);
    }


    //
    public function hasUpdatesFor($user = null)
    {
        // cache KEY
        $key = User::visitedThreadCacheKey($this);
        // Look in the cache for proper key
        // compare that carbon instance with $thread->updated_at

        // compare time instances with cache
        return ($this->updated_at) > (cache($key));
    }
}


